import os
import re
import sys
import shutil

##----------需要额外配置-------------##
exclude_class = ["Vector2","Vector3","Vector4"]


# 检查是否提供了输入文件路径和输出目录
if len(sys.argv) < 3:
    print("Usage: python script.py <path_to_schema.gd> <output_directory>")
    sys.exit(1)

# 获取输入文件路径和输出目录
input_file_path = sys.argv[1]
output_dir = sys.argv[2]


# 帮助函数
def is_tables(class_name):
    # 检查类名是否以 "Tb"+任意大写字母 开头
    if re.match(r"Tb[A-Z]", class_name):
        return True
    return False

# 清空文件夹
def clear_folder(folder_path):
    # Check if the folder exists
    if not os.path.exists(folder_path):
        print(f"The folder {folder_path} does not exist.")
        return
    
    # Loop through the contents of the folder
    for filename in os.listdir(folder_path):
        file_path = os.path.join(folder_path, filename)
        
        try:
            # Check if it is a file
            if os.path.isfile(file_path) or os.path.islink(file_path):
                os.unlink(file_path)  # Remove the file or link
            # Check if it is a directory
            elif os.path.isdir(file_path):
                shutil.rmtree(file_path)  # Remove the directory and its contents
        except Exception as e:
            print(f"Failed to delete {file_path}. Reason: {e}")

# 辅助函数：写入文件
def write_to_file(class_name, content, extends):
    # 排除不需要生成的类
    if class_name in exclude_class:
        return
    
    file_name = f"{class_name}.gd"
    if class_name.startswith("CfgTables"):
        dir_path = output_dir
    elif is_tables(class_name):
        dir_path = tables_dir
    else:
        dir_path = beans_dir

    with open(os.path.join(dir_path, file_name), "w", encoding="utf-8") as f:
        f.write("#  <auto-generated>\n")
        f.write("#    This code was generated by a tool.\n")
        f.write("#    Changes to this file may cause incorrect behavior and will be lost if\n")
        f.write("#    the code is regenerated.\n")
        f.write("#  </auto-generated>\n\n")

        f.write(f"extends {extends}\n")
        f.write(f"class_name {class_name}\n")
        f.write("".join(content))


# 定义目录
beans_dir = os.path.join(output_dir, "beans")
tables_dir = os.path.join(output_dir, "tables")

clear_folder(output_dir)

# 创建目录（如果不存在）
os.makedirs(beans_dir, exist_ok=True)
os.makedirs(tables_dir, exist_ok=True)



# 读取原始文件
with open(input_file_path, "r", encoding="utf-8") as file:
    lines = file.readlines()

current_class = None
current_content = []
class_info = []


# 遍历文件行
for line in lines:
    class_match = re.match(r"class (\w+)(?: extends (\w+))?:", line)
    if class_match:
        # 保存前一个类的内容
        if current_class and current_content:
            write_to_file(current_class, current_content, current_extends)
            class_info.append((current_class, current_extends))
        
        # 开始新的类
        current_class = class_match.group(1)
        current_extends = class_match.group(2) if class_match.group(2) else "RefCounted"
        current_content = []
        current_content.append("\n")
    else:
        if current_content is not None:
            # 移除一个制表符
            if line.startswith("\t"):
                current_content.append(line[1:])
            elif line.startswith("    "):
                current_content.append(line[4:])
            else:
                current_content.append(line)

# 保存最后一个类的内容
if current_class and current_content:
    write_to_file(current_class, current_content, current_extends)
    class_info.append((current_class, current_extends))

## enum 处理部分
current_enum = None
current_content_enum = []
enum_total = []

# 辅助函数：写入文件
def write_to_file_enum(content):
    file_name = f"StaticEnum.gd"
    dir_path = output_dir

    with open(os.path.join(dir_path, file_name), "w", encoding="utf-8") as f:
        f.write("#  <auto-generated>\n")
        f.write("#    This code was generated by a tool.\n")
        f.write("#    Changes to this file may cause incorrect behavior and will be lost if\n")
        f.write("#    the code is regenerated.\n")
        f.write("#  </auto-generated>\n\n")

        f.write(f"class_name StaticEnum\n\n")
        f.write("".join(current_content_enum))


for line in lines:
    class_match = re.match(r"class (\w+)(?: extends (\w+))?:", line)
    if class_match:
        break
    if line.startswith("enum"):
        current_enum = line[5:]
        current_content_enum.append(f"enum {current_enum}")
    else:
        if current_enum is not None:
            current_content_enum.append(line)

write_to_file_enum(current_content_enum)

## 清除_raw_gen
clear_folder(input_file_path+"/..")